<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Medicare QR Scanner</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');
body { margin:0; padding:0; font-family:'Roboto',sans-serif; background:#121212; color:#fff; display:flex; flex-direction:column; align-items:center; min-height:100vh;}
h1 { margin-top:20px; font-weight:700;}
.glass-container { background: rgba(255,255,255,0.05); border-radius:15px; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); box-shadow:0 8px 32px rgba(0,0,0,0.4); padding:20px 30px; margin:20px; max-width:500px; width:90%; }
video { width:100%; border-radius:12px; border:1px solid rgba(255,255,255,0.2); min-height:200px; background:#000; }
.info-container { display:flex; flex-direction:column; gap:10px; }
.field { background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); padding:10px 12px; border-radius:10px; color:#e0e0e0; font-size:16px; display:flex; gap:8px; align-items:flex-start; word-break:break-word; }
.field span.label { font-weight:600; color:#fff; min-width:120px; display:inline-block; }
.field .value { color:#e6e6e6; flex:1; }
.sub-field { padding:8px 10px; border-radius:8px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); }
p { text-align:center; color:#aaa; margin-top:8px; font-size:14px; }
#tapNotice { color:#ccc; font-size:14px; margin-top:10px; text-align:center; }
#switchBtn { margin-top:10px; padding:8px 12px; border-radius:8px; border:none; background: rgba(255,255,255,0.1); color:#fff; cursor:pointer; font-size:14px; }
@media (max-width:420px){
.field span.label { min-width:90px; font-size:14px; }
.field { font-size:15px; }
}
</style>
</head>
<body>

<h1>Medicare QR Scanner</h1>

<div class="glass-container">
<video id="video" autoplay playsinline></video>
<p>Point your camera at the patient's QR code</p>
<p id="tapNotice"></p>
<button id="switchBtn">Switch Camera</button>
</div>

<div class="glass-container info-container" id="patient-info">
<h2>Patient Info:</h2>
</div>

<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<script>
const video = document.getElementById('video');
const infoContainer = document.getElementById('patient-info');
const tapNotice = document.getElementById('tapNotice');
const switchBtn = document.getElementById('switchBtn');
let lastPatientCode = null;
let devices = [];
let currentDeviceIndex = 0;

// Detect iOS
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

// Parse underscore-delimited patient info.
// Each field is like "Label:Value" and fields separated by underscores.
// If a value contains slashes, split the value into multiple pieces.
function parsePatientData(data) {
// Safety: trim and avoid empty strings
return data.split('_').map(f => {
const raw = f.trim();
if (!raw) return null;
const parts = raw.split(':');
if (parts.length < 2) return null;
const label = parts[0].trim();
const valueRaw = parts.slice(1).join(':').trim();
// Split by slash '/', but ignore empty pieces. Trim each piece.
const pieces = valueRaw.split('/').map(p => p.trim()).filter(p => p.length>0);
// if there were no slashes, pieces is still single item
return { label, pieces };
}).filter(f => f !== null);
}

// Display patient info: each slash-separated piece gets its own box
function displayPatientInfo(fields){
// remove old fields except the heading (h2)
infoContainer.querySelectorAll('.field').forEach(el => el.remove());

fields.forEach(f => {
if (!f.pieces || f.pieces.length === 0) return;

// Create a box for the first piece with the label
const firstDiv = document.createElement('div');
firstDiv.className = 'field';
const labelSpan = document.createElement('span');
labelSpan.className = 'label';
labelSpan.textContent = f.label + ':';
const valueDiv = document.createElement('div');
valueDiv.className = 'value';
valueDiv.textContent = f.pieces[0];
firstDiv.appendChild(labelSpan);
firstDiv.appendChild(valueDiv);
infoContainer.appendChild(firstDiv);

// If there are more pieces (slash-separated), create separate smaller boxes for each
if (f.pieces.length > 1) {
// Wrap the extra pieces in a container so they appear grouped visually
const extraContainer = document.createElement('div');
extraContainer.style.display = 'flex';
extraContainer.style.flexDirection = 'column';
extraContainer.style.gap = '8px';
extraContainer.style.marginLeft = '0'; // keep aligned under the field
// For each remaining piece, create a sub-field (no repeated label)
for (let i = 1; i < f.pieces.length; i++) {
const sub = document.createElement('div');
sub.className = 'field sub-field';
// create an empty placeholder span for label to keep alignment
const emptyLabel = document.createElement('span');
emptyLabel.className = 'label';
emptyLabel.textContent = ''; // no text
emptyLabel.style.opacity = '0.6';
const subVal = document.createElement('div');
subVal.className = 'value';
subVal.textContent = f.pieces[i];
sub.appendChild(emptyLabel);
sub.appendChild(subVal);
extraContainer.appendChild(sub);
}
infoContainer.appendChild(extraContainer);
}
});

// Scroll to info (smooth)
infoContainer.scrollIntoView({ behavior: 'smooth' });
}

// Continuous scanning
function scanLoop(){
if(video.readyState === video.HAVE_ENOUGH_DATA){
const canvas = document.createElement('canvas');
canvas.width = video.videoWidth;
canvas.height = video.videoHeight;
const ctx = canvas.getContext('2d');
ctx.drawImage(video,0,0,canvas.width,canvas.height);
const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
const code = jsQR(imageData.data,imageData.width,imageData.height);
if(code && code.data !== lastPatientCode){
lastPatientCode = code.data;
const fields = parsePatientData(code.data);
if(fields.length > 0) displayPatientInfo(fields);
}
}
requestAnimationFrame(scanLoop);
}

// Start camera by deviceId or facingMode
async function startCameraByDevice(deviceId){
try {
// stop any existing tracks first to avoid camera conflicts
if (video.srcObject) {
const tracks = video.srcObject.getTracks();
tracks.forEach(t => t.stop());
}

let constraints = {};
if (deviceId) {
constraints = { video: { deviceId: { exact: deviceId } } };
} else {
// Force environment (back) camera if available
constraints = { video: { facingMode: { exact: "environment" } } };
}
const stream = await navigator.mediaDevices.getUserMedia(constraints);
video.srcObject = stream;
} catch (err) {
console.error("Camera access failed:", err);
// fallback: try without exact facingMode (some browsers don't allow exact)
try {
const fallbackStream = await navigator.mediaDevices.getUserMedia({ video: true });
video.srcObject = fallbackStream;
} catch (e) {
alert("Camera access failed: " + (err.message || err));
}
}
}

// Initialize camera
async function initCamera(){
try {
devices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
} catch (e) {
devices = [];
}

if(devices.length === 0){
// Try to start camera by facingMode fallback (some browsers won't list devices until permission)
if (isIOS) {
tapNotice.textContent = "Tap anywhere to start camera";
document.body.addEventListener('click', async () => {
await startCameraByDevice(null);
tapNotice.textContent = "";
}, { once: true });
} else {
try {
await startCameraByDevice(null);
} catch (e) {
alert("No camera found or access denied.");
}
}
return;
}

if(isIOS){
tapNotice.textContent = "Tap anywhere to start camera";
document.body.addEventListener('click', async ()=>{
// iOS: try environment camera
await startCameraByDevice(null);
tapNotice.textContent = "";
}, {once:true});
} else {
// Non-iOS: try back camera by label, fallback to first
const rear = devices.find(d=>d.label.toLowerCase().includes('back')) || devices.find(d=>d.label.toLowerCase().includes('rear')) || devices[0];
currentDeviceIndex = devices.indexOf(rear);
await startCameraByDevice(rear.deviceId);
}

// Switch camera button
switchBtn.addEventListener('click', async ()=>{
if(devices.length < 2) {
// if devices list is not populated, attempt generic toggle via facingMode
await startCameraByDevice(null);
return;
}
currentDeviceIndex = (currentDeviceIndex + 1) % devices.length;
await startCameraByDevice(devices[currentDeviceIndex].deviceId);
});
}

video.addEventListener('loadedmetadata', ()=>{ scanLoop(); });
initCamera();
</script>

</body>
</html>
